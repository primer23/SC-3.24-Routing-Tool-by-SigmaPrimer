<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Star Citizen Routing Tool</title>
    <!-- Include jQuery and jQuery UI CSS -->
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <!-- Include viewport meta tag for mobile responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Global Styles */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        /* Container */
        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        /* Sections */
        .section {
            padding: 20px;
            box-sizing: border-box;
        }

        /* Section Titles */
        .section-title {
            font-size: 24px;
            margin-bottom: 10px;
        }

        /* Input Rows */
        .input-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 10px;
        }

        .input-row label {
            flex: 1 1 100%;
            margin-bottom: 5px;
        }

        .input-row input, .input-row select, .input-row textarea {
            flex: 1 1 100%;
            padding: 10px;
            font-size: 16px;
        }

        /* Button Rows */
        .button-row {
            text-align: center;
            margin-top: 20px;
        }

        .button-row button {
            padding: 15px 25px;
            margin: 5px;
            font-size: 16px;
            width: 100%;
            max-width: 250px;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            table-layout: fixed;
            word-wrap: break-word;
        }

        table, th, td {
            border: 1px solid #ccc;
        }

        th, td {
            padding: 8px;
            text-align: left;
        }

        /* Output */
        #route-output {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
        }

        /* Map Styles */
        #map-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }

        #route-map {
            width: 100%;
            border: 1px solid #ccc;
            background-color: #000;
            cursor: grab;
        }

        /* Overlay for Location Lists */
        #location-list-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 300px;
            max-height: 80%;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            display: none;
            border-radius: 5px;
        }

        /* Media Queries for Desktop */
        @media (min-width: 1024px) {
            .container {
                flex-direction: row;
            }

            .left-column, .right-column {
                width: 50%;
                box-sizing: border-box;
            }

            .left-column {
                padding-right: 10px;
            }

            .right-column {
                padding-left: 10px;
            }
        }

        /* Media Queries for Mobile Responsiveness */
        @media (max-width: 768px) {
            .button-row button {
                font-size: 18px;
            }

            .section-title {
                font-size: 22px;
            }
        }

        @media (max-width: 480px) {
            .button-row button {
                font-size: 16px;
                padding: 12px 20px;
            }

            .section-title {
                font-size: 20px;
            }
        }

        /* Selected Row */
        .selected {
            background-color: #e0e0e0;
        }

        /* Reset Button */
        #reset-map-button {
            margin-top: 10px;
        }

        /* Remove Button */
        .remove-button {
            margin-top: 10px;
            color: red;
        }
    </style>
</head>
<body>

    <div class="container">
        <!-- Left Column -->
        <div class="left-column">
            <!-- Mission Input Section -->
            <div class="section">
                <h2 class="section-title">SC 3.24 Hauling Missions Routing Tool v1 by SigmaPrimer</h2>
                <!-- Starting Location (now optional here) -->
                <div class="input-row">
                    <label for="mission-type">Mission Type:</label>
                    <select id="mission-type">
                        <option value="">Select Mission Type</option>
                        <option value="Direct">Direct</option>
                        <option value="Multi Drop-Off">Multi Drop-Off</option>
                        <option value="Multi Pick-Up">Multi Pick-Up</option>
                    </select>
                </div>
                <div class="input-row">
                    <label for="mission-subcategory">Mission Subcategory:</label>
                    <select id="mission-subcategory">
                        <option value="">Select Subcategory</option>
                        <option value="Planetary">Planetary</option>
                        <option value="Solar">Solar</option>
                        <option value="Interstellar">Interstellar</option>
                    </select>
                </div>
                <div id="location-section" style="display: none;">
                    <!-- Dynamic Content Will Be Inserted Here -->
                </div>
                <div class="button-row">
                    <button id="add-mission-button" style="display: none;">Add Mission</button>
                </div>
            </div>

            <!-- Missions Table -->
            <div class="section">
                <h2 class="section-title">Missions</h2>
                <table id="missions-table">
                    <thead>
                        <tr>
                            <th>Mission Type</th>
                            <th>Subcategory</th>
                            <th>Commodities</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Missions will be added here -->
                    </tbody>
                </table>
                <div class="button-row">
                    <button id="clear-missions-button">Clear All Missions</button>
                </div>
            </div>

            <!-- Route Calculation Section -->
            <div class="section">
                <div class="input-row">
                    <label for="starting-location">Starting Location:</label>
                    <input type="text" id="starting-location">
                </div>
                <div class="button-row">
                    <button id="calculate-route-button" style="display: none;">Calculate Optimized Route</button>
                </div>
                <div id="route-output"></div>
            </div>
        </div>

        <!-- Right Column (Map) -->
        <div class="right-column">
            <div class="section">
                <h2 class="section-title">Map</h2>
                <div id="map-container">
                    <canvas id="route-map" width="600" height="600"></canvas>
                    <div id="location-list-overlay"></div>
                    <button id="reset-map-button">Reset Map</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Include jQuery and jQuery UI -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Include jQuery UI for autocomplete -->
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>

    <script>
        // Data Structures

        // Positions of celestial bodies (x, y coordinates in units)
        const celestialBodies = {
            "Stanton Star": { x: 0, y: 0 },
            // Planets
            "Hurston": { x: 100, y: 0 },
            "Crusader": { x: -180, y: 0 },
            "ArcCorp": { x: 176.78, y: -176.78 },
            "MicroTech": { x: 247.49, y: 247.49 },
            // Jump Points (will be updated later)
            "Stanton-Magnus": { x: 450 * Math.cos(155 * Math.PI / 180), y: 450 * Math.sin(155 * Math.PI / 180) }, // Approximate position
            // Lagrange Points (will be added dynamically)
        };

        // Function to calculate positions of Lagrange Points for each planet
        function calculateLagrangePoints() {
            const planets = ["Hurston", "Crusader", "ArcCorp", "MicroTech"];
            const codes = {"Hurston": "HUR", "Crusader": "CRU", "ArcCorp": "ARC", "MicroTech": "MIC"};
            planets.forEach(planet => {
                const code = codes[planet];
                const planetPos = celestialBodies[planet];
                const distanceToStar = Math.hypot(planetPos.x, planetPos.y);
                const unitVector = { x: planetPos.x / distanceToStar, y: planetPos.y / distanceToStar };
                const delta = 5; // Arbitrary small distance

                // L1
                celestialBodies[code + "-L1"] = {
                    x: planetPos.x - delta * unitVector.x,
                    y: planetPos.y - delta * unitVector.y
                };

                // L2
                celestialBodies[code + "-L2"] = {
                    x: planetPos.x + delta * unitVector.x,
                    y: planetPos.y + delta * unitVector.y
                };

                // L3
                celestialBodies[code + "-L3"] = {
                    x: -planetPos.x,
                    y: -planetPos.y
                };

                // L4 and L5
                const angle = Math.atan2(planetPos.y, planetPos.x);
                const r = distanceToStar;
                const l4Angle = angle + (Math.PI / 3); // 60 degrees
                const l5Angle = angle - (Math.PI / 3);

                celestialBodies[code + "-L4"] = {
                    x: r * Math.cos(l4Angle),
                    y: r * Math.sin(l4Angle)
                };

                celestialBodies[code + "-L5"] = {
                    x: r * Math.cos(l5Angle),
                    y: r * Math.sin(l5Angle)
                };
            });
        }

        // Call the function to populate Lagrange Points
        calculateLagrangePoints();

        // Adjust the positions of the jump points according to the user's request
        function adjustJumpPoints() {
            const starPos = celestialBodies['Stanton Star'];

            // Adjust Stanton-Pyro Jump Point
            // Located between ArcCorp and ARC-L5
            const arcCorpPos = celestialBodies['ArcCorp'];
            const arcL5Pos = celestialBodies['ARC-L5'];

            // Positions relative to the star
            const arcCorpRelX = arcCorpPos.x - starPos.x;
            const arcCorpRelY = arcCorpPos.y - starPos.y;
            const arcL5RelX = arcL5Pos.x - starPos.x;
            const arcL5RelY = arcL5Pos.y - starPos.y;

            // Compute angles
            const arcCorpAngle = Math.atan2(arcCorpRelY, arcCorpRelX);
            const arcL5Angle = Math.atan2(arcL5RelY, arcL5RelX);

            // Compute angular difference
            let angleDifference = arcL5Angle - arcCorpAngle;
            if (angleDifference < -Math.PI) {
                angleDifference += 2 * Math.PI;
            } else if (angleDifference > Math.PI) {
                angleDifference -= 2 * Math.PI;
            }

            // Compute mid-angle
            const midAngle = arcCorpAngle + angleDifference / 2;

            // Compute average distance and offset by 5 units away from the star
            const arcCorpDistance = Math.hypot(arcCorpRelX, arcCorpRelY);
            const arcL5Distance = Math.hypot(arcL5RelX, arcL5RelY);
            const midDistance = (arcCorpDistance + arcL5Distance) / 2 + 5;

            // Compute new position
            const stantonPyroX = starPos.x + midDistance * Math.cos(midAngle);
            const stantonPyroY = starPos.y + midDistance * Math.sin(midAngle);

            celestialBodies['Stanton-Pyro'] = { x: stantonPyroX, y: stantonPyroY };

            // Adjust Stanton-Terra Jump Point to be 20 units outside MicroTech's orbital ring, next to MIC-L5
            const microTechPos = celestialBodies['MicroTech'];
            const micL5Pos = celestialBodies['MIC-L5'];

            // Compute the vector from the star to MIC-L5
            const micL5Vector = {
                x: micL5Pos.x - starPos.x,
                y: micL5Pos.y - starPos.y
            };

            // Compute the distance from the star to MicroTech (orbital radius)
            const microTechDistance = Math.hypot(microTechPos.x - starPos.x, microTechPos.y - starPos.y);

            // Compute the unit vector in the direction of MIC-L5
            const micL5Distance = Math.hypot(micL5Vector.x, micL5Vector.y);
            const unitVector = {
                x: micL5Vector.x / micL5Distance,
                y: micL5Vector.y / micL5Distance
            };

            // Position of the Terra jump point: at a distance of (microTechDistance + 20) units from the star
            const terraJumpDistance = microTechDistance + 20;
            const stantonTerraX = starPos.x + terraJumpDistance * unitVector.x;
            const stantonTerraY = starPos.y + terraJumpDistance * unitVector.y;

            celestialBodies['Stanton-Terra'] = { x: stantonTerraX, y: stantonTerraY };
        }

        // Call the function to adjust jump points
        adjustJumpPoints();

        // Moon orders as per your specification
        const moonOrders = {
            "Hurston": ["Arial", "Aberdeen", "Magda", "Ita"],
            "Crusader": ["Cellin", "Daymar", "Yela"],
            "ArcCorp": ["Lyria", "Wala"],
            "MicroTech": ["Calliope", "Cleo", "Euterpe"]
        };

        // Locations Data
        const data = {
            "Hurston": {
                "Planetary Locations": {
                    "Landing Zone": "Lorville",
                    "Orbital Station": "Everus Harbour",
                    "Distribution Centres": [
                        "HDPC-Farnesway", "HDPC-Cassillo", "Covalex Distribution Centre S1DC06",
                        "Greycat Stanton Production Complex-B", "Dupree Industrial Manufacturing Facility", "Sakura Sun Magnolia Workcentre"
                    ],
                    "Outposts": [
                        "HDMS-Oparei", "HDMS-Pinewood", "HDMS-Edmond", "HDMS-Hadley", "HDMS-Thedus", "HDMS-Stanhope"
                    ]
                },
                "Moons": {
                    "Arial": ["HDMS-Latham", "HDMS-Bezdek"],
                    "Aberdeen": ["HDMS-Norgaard", "HDMS-Anderson"],
                    "Magda": ["HDMS-Perlman", "HDMS-Hahn"],
                    "Ita": ["HDMS-Ryder", "HDMS-Woodruff"]
                }
            },
            "MicroTech": {
                "Planetary Locations": {
                    "Landing Zone": "New Babbage",
                    "Orbital Station": "Port Tressler",
                    "Distribution Centres": [
                        "microTech Logistics Depot S4LD01", "Cry-Astro Processing Plant 19-02", "Covalex Distribution Centre S4DC05",
                        "microTech Logistics Depot S4LD13", "Greycat Stanton IV Production Complex-A", "Cry-Astro Processing Plant 34-12"
                    ],
                    "Outposts": [
                        "Shubin Mining Facility SMO-13", "Shubin Mining Facility SMO-22", "Shubin Mining Facility SMO-18",
                        "Shubin Mining Facility SMO-10", "Rayari Deltana Research Outpost"
                    ]
                },
                "Moons": {
                    "Calliope": ["Rayari Anvik Research Outpost", "Rayari Kaltag Research Outpost", "Shubin Mining Facility SMCa-8", "Shubin Mining Facility SMCa-6"],
                    "Cleo": ["Rayari Cantwell Research Outpost", "Rayari McGrath Research Outpost"],
                    "Euterpe": ["Devlin Scrap & Salvage", "Bud's Growery"]
                }
            },
            "ArcCorp": {
                "Planetary Locations": {
                    "Landing Zone": "Area 18",
                    "Orbital Station": "Bajini Point"
                },
                "Moons": {
                    "Lyria": ["Shubin Mining Facility SAL-2", "Shubin Mining Facility SAL-5"],
                    "Wala": ["ArcCorp Mining Area 048", "ArcCorp Mining Area 045", "ArcCorp Mining Area 061", "ArcCorp Mining Area 056", "Samson & Son's Salvage Center"]
                }
            },
            "Crusader": {
                "Planetary Locations": {
                    "Landing Zone": "Orison",
                    "Orbital Station": "Seraphim Station"
                },
                "Moons": {
                    "Cellin": ["Hickes Research Outpost", "Terra Mills HydroFarm"],
                    "Daymar": ["ArcCorp Mining Area 141", "Shubin Mining Facility SCD-1", "Brio's Breaker Yard"],
                    "Yela": ["Deakins Research Outpost", "ArcCorp Mining Area 157"]
                }
            },
            "Lagrange Points": {
                "Crusader-Stanton": ["CRU-L1", "CRU-L2", "CRU-L3", "CRU-L4", "CRU-L5"],
                "Hurston-Stanton": ["HUR-L1", "HUR-L2", "HUR-L3", "HUR-L4", "HUR-L5"],
                "ArcCorp-Stanton": ["ARC-L1", "ARC-L2", "ARC-L3", "ARC-L4", "ARC-L5"],
                "MicroTech-Stanton": ["MIC-L1", "MIC-L2", "MIC-L3", "MIC-L4", "MIC-L5"]
            },
            "Jump Points": ["Stanton-Pyro", "Stanton-Terra", "Stanton-Magnus"]
        };

        // Mapping from locations to their types and parent planets
        let locationTypes = {};
        let locationToPlanet = {};

        // Orbital Stations mapping
        const orbitalStations = {
            "Hurston": "Everus Harbour",
            "MicroTech": "Port Tressler",
            "ArcCorp": "Bajini Point",
            "Crusader": "Seraphim Station"
        };

        // Assign positions to planetary locations and moons
        function assignPositionsToLocations() {
            const planetPositions = {
                "Hurston": celestialBodies["Hurston"],
                "Crusader": celestialBodies["Crusader"],
                "ArcCorp": celestialBodies["ArcCorp"],
                "MicroTech": celestialBodies["MicroTech"]
            };

            const locationRadius = 1; // Smaller radius for locations

            // For each planet
            for (let planet in data) {
                if (planet === "Lagrange Points" || planet === "Jump Points") continue;

                const planetPos = planetPositions[planet];

                // Map planet
                locationTypes[planet] = "Planet";

                // Assign positions to planetary locations (positions will be assigned for orbital stations)
                if (data[planet]["Planetary Locations"]) {
                    const planetaryLocations = data[planet]["Planetary Locations"];

                    for (let category in planetaryLocations) {
                        if (category === "Orbital Station") {
                            const orbitalStationName = planetaryLocations[category];
                            celestialBodies[orbitalStationName] = generateRandomPositionAround(planetPos, 0.1); // Assign position very close to the planet
                            locationTypes[orbitalStationName] = "Orbital Station";
                            locationToPlanet[orbitalStationName] = planet;
                            continue; // Include orbital stations as selectable locations
                        }

                        const locations = planetaryLocations[category];

                        if (typeof locations === "string") {
                            // Single location
                            const locName = locations;
                            locationTypes[locName] = "Planetary Location";
                            locationToPlanet[locName] = planet;
                        } else if (Array.isArray(locations)) {
                            // Multiple locations
                            locations.forEach((locName) => {
                                locationTypes[locName] = "Planetary Location";
                                locationToPlanet[locName] = planet;
                            });
                        }
                    }
                }

                // Assign positions to moons
                if (data[planet]["Moons"]) {
                    const moons = data[planet]["Moons"];
                    const moonNames = moonOrders[planet]; // Use specified moon order
                    const moonCount = moonNames.length;

                    moonNames.forEach((moonName, moonIndex) => {
                        // Map moon
                        locationTypes[moonName] = "Moon";
                        locationToPlanet[moonName] = planet;

                        // Calculate moon orbital radius
                        const orbitalRadius = 2.5 + (moonIndex * 0.5);

                        // Generate angle to prevent overlap
                        const angleRad = (moonIndex / moonCount) * 2 * Math.PI;

                        const moonX = planetPos.x + orbitalRadius * Math.cos(angleRad);
                        const moonY = planetPos.y + orbitalRadius * Math.sin(angleRad);
                        const moonPos = { x: moonX, y: moonY };

                        // Assign moon position
                        celestialBodies[moonName] = moonPos;

                        // Assign positions to moon locations (positions will be assigned when zoomed in)
                        const moonLocations = moons[moonName];
                        moonLocations.forEach((locName) => {
                            locationTypes[locName] = "Moon Location";
                            locationToPlanet[locName] = moonName;
                        });
                    });
                }
            }

            // Assign types to Lagrange Points
            if (data["Lagrange Points"]) {
                for (let key in data["Lagrange Points"]) {
                    const lagrangePoints = data["Lagrange Points"][key];
                    lagrangePoints.forEach(lp => {
                        locationTypes[lp] = "Lagrange Point";
                        celestialBodies[lp] = celestialBodies[lp] || { x: 0, y: 0 }; // Ensure position exists
                    });
                }
            }

            // Assign types to Jump Points
            if (data["Jump Points"]) {
                data["Jump Points"].forEach(jp => {
                    locationTypes[jp] = "Jump Point";
                    celestialBodies[jp] = celestialBodies[jp] || { x: 0, y: 0 }; // Ensure position exists
                });
            }
        }

        // Call the function to assign positions
        assignPositionsToLocations();

        // Gather all locations
        function gatherAllLocations() {
            let allLocations = [];
            for (let planet in data) {
                if (data[planet]["Planetary Locations"]) {
                    let planetaryLocations = data[planet]["Planetary Locations"];
                    for (let key in planetaryLocations) {
                        if (typeof planetaryLocations[key] === "string") {
                            allLocations.push(planetaryLocations[key]);
                        } else if (Array.isArray(planetaryLocations[key])) {
                            allLocations = allLocations.concat(planetaryLocations[key]);
                        }
                    }
                }
                if (data[planet]["Moons"]) {
                    for (let moon in data[planet]["Moons"]) {
                        allLocations.push(moon); // Include moon names
                        allLocations = allLocations.concat(data[planet]["Moons"][moon]);
                    }
                }
                if (planet === "Lagrange Points") {
                    for (let points in data[planet]) {
                        allLocations = allLocations.concat(data[planet][points]);
                    }
                }
                if (planet === "Jump Points") {
                    allLocations = allLocations.concat(data[planet]);
                }
            }
            return allLocations;
        }

        const allLocations = gatherAllLocations();

        // Missions Array
        let missions = [];
        let commodities = []; // All commodities with their pickup and drop-off locations

        // Initialize Autocomplete for Location Inputs
        function initializeAutocomplete(selector, availableLocations) {
            $(selector).autocomplete({
                source: availableLocations,
                minLength: 0,
                delay: 0
            }).focus(function () {
                $(this).autocomplete("search", "");
            });
        }

        // Initialize autocomplete for starting location
        const startingLocations = allLocations.filter(loc =>
            locationTypes[loc] === 'Planet' ||
            locationTypes[loc] === 'Moon' ||
            locationTypes[loc] === 'Orbital Station' ||
            locationTypes[loc] === 'Lagrange Point' ||
            locationTypes[loc] === 'Jump Point'
        );

        initializeAutocomplete("#starting-location", startingLocations);

        // Handle Mission Type and Subcategory Selection
        $("#mission-type, #mission-subcategory").change(function () {
            const missionType = $("#mission-type").val();
            const missionSubcategory = $("#mission-subcategory").val();

            if (missionType && missionSubcategory) {
                generateLocationInputs(missionType, missionSubcategory);
                $("#location-section").show();
                $("#add-mission-button").show();
            } else {
                $("#location-section").hide();
                $("#add-mission-button").hide();
            }
        });

        // Generate Location Inputs Based on Mission Type and Subcategory
        function generateLocationInputs(missionType, missionSubcategory) {
            const locationSection = $("#location-section");
            locationSection.empty();

            let availableLocations = allLocations.filter(loc => celestialBodies[loc] || locationTypes[loc] === 'Planet' || locationTypes[loc] === 'Moon' || locationTypes[loc] === 'Moon Location' || locationTypes[loc] === 'Planetary Location' || locationTypes[loc] === 'Orbital Station');

            if (missionSubcategory === "Planetary") {
                // Exclude Lagrange Points and Jump Points
                availableLocations = availableLocations.filter(loc => !loc.includes("-L") && !loc.includes("Stanton-") && locationTypes[loc] !== "Jump Point" && locationTypes[loc] !== "Lagrange Point");
            } else if (missionSubcategory === "Solar") {
                // Include Lagrange Points and orbital stations
                availableLocations = availableLocations.filter(loc => locationTypes[loc] === "Lagrange Point" || locationTypes[loc] === "Orbital Station");
            } else if (missionSubcategory === "Interstellar") {
                // Only orbital stations, jump points, and Lagrange points
                availableLocations = availableLocations.filter(loc => locationTypes[loc] === "Orbital Station" || locationTypes[loc] === "Jump Point" || locationTypes[loc] === "Lagrange Point");
            }

            if (missionType === "Direct") {
                // One pickup and one drop-off
                locationSection.append(`
                    <div class="input-row">
                        <label for="pickup-location">Pickup Location:</label>
                        <input type="text" id="pickup-location">
                    </div>
                    <div class="input-row">
                        <label for="dropoff-location">Drop-off Location:</label>
                        <input type="text" id="dropoff-location">
                    </div>
                `);
                initializeAutocomplete("#pickup-location", availableLocations);
                initializeAutocomplete("#dropoff-location", availableLocations);

                // Commodities Section
                locationSection.append(`
                    <div id="commodities-container">
                        <h3>Commodities</h3>
                        <div class="commodity-entry">
                            <div class="input-row">
                                <label for="commodity-type-1">Commodity Type:</label>
                                <input type="text" class="commodity-type" id="commodity-type-1">
                            </div>
                            <div class="input-row">
                                <label for="scu-amount-1">SCU Amount:</label>
                                <input type="number" class="scu-amount" id="scu-amount-1" min="0">
                            </div>
                            <button class="remove-commodity-button">Remove Commodity</button>
                        </div>
                        <button id="add-commodity-button">Add Another Commodity</button>
                    </div>
                `);
                let commodityCount = 1;
                $("#add-commodity-button").click(function (e) {
                    e.preventDefault();
                    commodityCount++;
                    $("#commodities-container").append(`
                        <div class="commodity-entry">
                            <div class="input-row">
                                <label for="commodity-type-${commodityCount}">Commodity Type:</label>
                                <input type="text" class="commodity-type" id="commodity-type-${commodityCount}">
                            </div>
                            <div class="input-row">
                                <label for="scu-amount-${commodityCount}">SCU Amount:</label>
                                <input type="number" class="scu-amount" id="scu-amount-${commodityCount}" min="0">
                            </div>
                            <button class="remove-commodity-button">Remove Commodity</button>
                        </div>
                    `);
                });
            } else if (missionType === "Multi Drop-Off") {
                // One pickup location, multiple drop-offs
                locationSection.append(`
                    <div class="input-row">
                        <label for="pickup-location">Pickup Location:</label>
                        <input type="text" id="pickup-location">
                    </div>
                    <div id="dropoff-locations-container">
                        <div class="dropoff-entry">
                            <div class="input-row">
                                <label for="dropoff-location-1">Drop-off Location 1:</label>
                                <input type="text" class="dropoff-location" id="dropoff-location-1">
                            </div>
                            <div class="input-row">
                                <label>Commodities for this Drop-off:</label>
                            </div>
                            <div class="commodity-container" id="commodity-container-1">
                                <div class="commodity-entry">
                                    <div class="input-row">
                                        <label for="commodity-type-1-1">Commodity Type:</label>
                                        <input type="text" class="commodity-type" id="commodity-type-1-1">
                                    </div>
                                    <div class="input-row">
                                        <label for="scu-amount-1-1">SCU Amount:</label>
                                        <input type="number" class="scu-amount" id="scu-amount-1-1" min="0">
                                    </div>
                                    <button class="remove-commodity-button">Remove Commodity</button>
                                </div>
                            </div>
                            <button class="add-commodity-button" data-dropoff="1">Add Another Commodity</button>
                            <button class="remove-dropoff-button">Remove Drop-off Location</button>
                        </div>
                    </div>
                    <button id="add-dropoff-button">Add Another Drop-off Location</button>
                `);
                initializeAutocomplete("#pickup-location", availableLocations);
                initializeAutocomplete("#dropoff-location-1", availableLocations);
                let dropoffCount = 1;
                let commodityCounts = { 1: 1 };

                $("#add-dropoff-button").click(function (e) {
                    e.preventDefault();
                    dropoffCount++;
                    commodityCounts[dropoffCount] = 1;
                    $("#dropoff-locations-container").append(`
                        <div class="dropoff-entry">
                            <div class="input-row">
                                <label for="dropoff-location-${dropoffCount}">Drop-off Location ${dropoffCount}:</label>
                                <input type="text" class="dropoff-location" id="dropoff-location-${dropoffCount}">
                            </div>
                            <div class="input-row">
                                <label>Commodities for this Drop-off:</label>
                            </div>
                            <div class="commodity-container" id="commodity-container-${dropoffCount}">
                                <div class="commodity-entry">
                                    <div class="input-row">
                                        <label for="commodity-type-${dropoffCount}-1">Commodity Type:</label>
                                        <input type="text" class="commodity-type" id="commodity-type-${dropoffCount}-1">
                                    </div>
                                    <div class="input-row">
                                        <label for="scu-amount-${dropoffCount}-1">SCU Amount:</label>
                                        <input type="number" class="scu-amount" id="scu-amount-${dropoffCount}-1" min="0">
                                    </div>
                                    <button class="remove-commodity-button">Remove Commodity</button>
                                </div>
                            </div>
                            <button class="add-commodity-button" data-dropoff="${dropoffCount}">Add Another Commodity</button>
                            <button class="remove-dropoff-button">Remove Drop-off Location</button>
                        </div>
                    `);
                    initializeAutocomplete(`#dropoff-location-${dropoffCount}`, availableLocations);
                });

                // Handle adding commodities for each drop-off
                $(document).on('click', '.add-commodity-button', function (e) {
                    e.preventDefault();
                    let dropoffIndex = $(this).data('dropoff');
                    commodityCounts[dropoffIndex]++;
                    $(`#commodity-container-${dropoffIndex}`).append(`
                        <div class="commodity-entry">
                            <div class="input-row">
                                <label for="commodity-type-${dropoffIndex}-${commodityCounts[dropoffIndex]}">Commodity Type:</label>
                                <input type="text" class="commodity-type" id="commodity-type-${dropoffIndex}-${commodityCounts[dropoffIndex]}">
                            </div>
                            <div class="input-row">
                                <label for="scu-amount-${dropoffIndex}-${commodityCounts[dropoffIndex]}">SCU Amount:</label>
                                <input type="number" class="scu-amount" id="scu-amount-${dropoffIndex}-${commodityCounts[dropoffIndex]}" min="0">
                            </div>
                            <button class="remove-commodity-button">Remove Commodity</button>
                        </div>
                    `);
                });

                // Handle removing drop-off locations
                $(document).on('click', '.remove-dropoff-button', function (e) {
                    e.preventDefault();
                    $(this).closest('.dropoff-entry').remove();
                });
            } else if (missionType === "Multi Pick-Up") {
                // Multiple pickup locations, one drop-off
                locationSection.append(`
                    <div id="pickup-locations-container">
                        <div class="pickup-entry">
                            <div class="input-row">
                                <label for="pickup-location-1">Pickup Location 1:</label>
                                <input type="text" class="pickup-location" id="pickup-location-1">
                            </div>
                            <div class="input-row">
                                <label>Commodities for this Pickup:</label>
                            </div>
                            <div class="commodity-container" id="commodity-container-1">
                                <div class="commodity-entry">
                                    <div class="input-row">
                                        <label for="commodity-type-1-1">Commodity Type:</label>
                                        <input type="text" class="commodity-type" id="commodity-type-1-1">
                                    </div>
                                    <div class="input-row">
                                        <label for="scu-amount-1-1">SCU Amount:</label>
                                        <input type="number" class="scu-amount" id="scu-amount-1-1" min="0">
                                    </div>
                                    <button class="remove-commodity-button">Remove Commodity</button>
                                </div>
                            </div>
                            <button class="add-commodity-button" data-pickup="1">Add Another Commodity</button>
                            <button class="remove-pickup-button">Remove Pickup Location</button>
                        </div>
                    </div>
                    <button id="add-pickup-button">Add Another Pickup Location</button>
                    <div class="input-row">
                        <label for="dropoff-location">Drop-off Location:</label>
                        <input type="text" id="dropoff-location">
                    </div>
                `);
                initializeAutocomplete("#dropoff-location", availableLocations);
                initializeAutocomplete("#pickup-location-1", availableLocations);
                let pickupCount = 1;
                let commodityCounts = { 1: 1 };

                $("#add-pickup-button").click(function (e) {
                    e.preventDefault();
                    pickupCount++;
                    commodityCounts[pickupCount] = 1;
                    $("#pickup-locations-container").append(`
                        <div class="pickup-entry">
                            <div class="input-row">
                                <label for="pickup-location-${pickupCount}">Pickup Location ${pickupCount}:</label>
                                <input type="text" class="pickup-location" id="pickup-location-${pickupCount}">
                            </div>
                            <div class="input-row">
                                <label>Commodities for this Pickup:</label>
                            </div>
                            <div class="commodity-container" id="commodity-container-${pickupCount}">
                                <div class="commodity-entry">
                                    <div class="input-row">
                                        <label for="commodity-type-${pickupCount}-1">Commodity Type:</label>
                                        <input type="text" class="commodity-type" id="commodity-type-${pickupCount}-1">
                                    </div>
                                    <div class="input-row">
                                        <label for="scu-amount-${pickupCount}-1">SCU Amount:</label>
                                        <input type="number" class="scu-amount" id="scu-amount-${pickupCount}-1" min="0">
                                    </div>
                                    <button class="remove-commodity-button">Remove Commodity</button>
                                </div>
                            </div>
                            <button class="add-commodity-button" data-pickup="${pickupCount}">Add Another Commodity</button>
                            <button class="remove-pickup-button">Remove Pickup Location</button>
                        </div>
                    `);
                    initializeAutocomplete(`#pickup-location-${pickupCount}`, availableLocations);
                });

                // Handle adding commodities for each pickup
                $(document).on('click', '.add-commodity-button', function (e) {
                    e.preventDefault();
                    let pickupIndex = $(this).data('pickup');
                    commodityCounts[pickupIndex]++;
                    $(`#commodity-container-${pickupIndex}`).append(`
                        <div class="commodity-entry">
                            <div class="input-row">
                                <label for="commodity-type-${pickupIndex}-${commodityCounts[pickupIndex]}">Commodity Type:</label>
                                <input type="text" class="commodity-type" id="commodity-type-${pickupIndex}-${commodityCounts[pickupIndex]}">
                            </div>
                            <div class="input-row">
                                <label for="scu-amount-${pickupIndex}-${commodityCounts[pickupIndex]}">SCU Amount:</label>
                                <input type="number" class="scu-amount" id="scu-amount-${pickupIndex}-${commodityCounts[pickupIndex]}" min="0">
                            </div>
                            <button class="remove-commodity-button">Remove Commodity</button>
                        </div>
                    `);
                });

                // Handle removing pickup locations
                $(document).on('click', '.remove-pickup-button', function (e) {
                    e.preventDefault();
                    $(this).closest('.pickup-entry').remove();
                });
            }

            // Handle removing commodities
            $(document).on('click', '.remove-commodity-button', function (e) {
                e.preventDefault();
                $(this).closest('.commodity-entry').remove();
            });
        }

        // Add Mission Button Click Event
        $("#add-mission-button").click(function () {
            const missionType = $("#mission-type").val();
            const missionSubcategory = $("#mission-subcategory").val();
            let availableLocations = allLocations.filter(loc => celestialBodies[loc] || locationTypes[loc] === 'Planet' || locationTypes[loc] === 'Moon' || locationTypes[loc] === 'Moon Location' || locationTypes[loc] === 'Planetary Location' || locationTypes[loc] === 'Orbital Station');

            if (missionSubcategory === "Planetary") {
                // Exclude Lagrange Points and Jump Points
                availableLocations = availableLocations.filter(loc => !loc.includes("-L") && !loc.includes("Stanton-") && locationTypes[loc] !== "Jump Point" && locationTypes[loc] !== "Lagrange Point");
            } else if (missionSubcategory === "Solar") {
                // Include Lagrange Points and orbital stations
                availableLocations = availableLocations.filter(loc => locationTypes[loc] === "Lagrange Point" || locationTypes[loc] === "Orbital Station");
            } else if (missionSubcategory === "Interstellar") {
                // Only orbital stations, jump points, and Lagrange points
                availableLocations = availableLocations.filter(loc => locationTypes[loc] === "Orbital Station" || locationTypes[loc] === "Jump Point" || locationTypes[loc] === "Lagrange Point");
            }

            let mission = {
                missionType: missionType,
                missionSubcategory: missionSubcategory,
                commodities: []
            };
            let validInput = true;

            if (missionType === "Direct") {
                const pickup = $("#pickup-location").val().trim();
                const dropoff = $("#dropoff-location").val().trim();

                if (!availableLocations.includes(pickup) || !availableLocations.includes(dropoff)) {
                    alert("Invalid pickup or drop-off location.");
                    validInput = false;
                }

                // Get Commodities
                $(".commodity-type").each(function (index) {
                    const commodityType = $(this).val().trim();
                    const scuAmount = parseInt($(".scu-amount").eq(index).val().trim());
                    if (commodityType && scuAmount > 0) {
                        mission.commodities.push({
                            type: commodityType,
                            amount: scuAmount,
                            pickup: pickup,
                            dropoff: dropoff
                        });
                    }
                });

                if (mission.commodities.length === 0) {
                    alert("Please enter at least one commodity.");
                    validInput = false;
                }
            } else if (missionType === "Multi Drop-Off") {
                const pickup = $("#pickup-location").val().trim();
                if (!availableLocations.includes(pickup)) {
                    alert("Invalid pickup location.");
                    validInput = false;
                }

                $(".dropoff-entry").each(function (index) {
                    const dropoff = $(this).find(".dropoff-location").val().trim();
                    if (!availableLocations.includes(dropoff)) {
                        alert("Invalid drop-off location: " + dropoff);
                        validInput = false;
                    } else {
                        $(this).find(".commodity-entry").each(function () {
                            const commodityType = $(this).find(".commodity-type").val().trim();
                            const scuAmount = parseInt($(this).find(".scu-amount").val().trim());
                            if (commodityType && scuAmount > 0) {
                                mission.commodities.push({
                                    type: commodityType,
                                    amount: scuAmount,
                                    pickup: pickup,
                                    dropoff: dropoff
                                });
                            }
                        });
                    }
                });

                if (mission.commodities.length === 0) {
                    alert("Please enter at least one commodity.");
                    validInput = false;
                }
            } else if (missionType === "Multi Pick-Up") {
                const dropoff = $("#dropoff-location").val().trim();
                if (!availableLocations.includes(dropoff)) {
                    alert("Invalid drop-off location.");
                    validInput = false;
                }

                $(".pickup-entry").each(function (index) {
                    const pickup = $(this).find(".pickup-location").val().trim();
                    if (!availableLocations.includes(pickup)) {
                        alert("Invalid pickup location: " + pickup);
                        validInput = false;
                    } else {
                        $(this).find(".commodity-entry").each(function () {
                            const commodityType = $(this).find(".commodity-type").val().trim();
                            const scuAmount = parseInt($(this).find(".scu-amount").val().trim());
                            if (commodityType && scuAmount > 0) {
                                mission.commodities.push({
                                    type: commodityType,
                                    amount: scuAmount,
                                    pickup: pickup,
                                    dropoff: dropoff
                                });
                            }
                        });
                    }
                });

                if (mission.commodities.length === 0) {
                    alert("Please enter at least one commodity.");
                    validInput = false;
                }
            }

            if (validInput) {
                // Assign a color to the mission
                const missionColors = ['red', 'blue', 'green', 'orange', 'purple', 'cyan', 'magenta', 'yellow'];
                mission.color = missionColors[missions.length % missionColors.length];

                missions.push(mission);
                commodities = commodities.concat(mission.commodities);
                displayMissions();
                $("#calculate-route-button").show();
                // Reset form
                $("#mission-type").val('');
                $("#mission-subcategory").val('');
                $("#location-section").hide();
                $("#add-mission-button").hide();
            }
        });

        // Display Missions
        function displayMissions() {
            const tbody = $("#missions-table tbody");
            tbody.empty();
            missions.forEach((mission, index) => {
                let commoditiesStr = mission.commodities.map(c => {
                    return `${c.type} (${c.amount} SCU) from ${c.pickup} to ${c.dropoff}`;
                }).join('; ');
                tbody.append(`
                    <tr>
                        <td>${mission.missionType}</td>
                        <td>${mission.missionSubcategory}</td>
                        <td>${commoditiesStr}</td>
                    </tr>
                `);
            });
        }

        // Clear All Missions Button
        $("#clear-missions-button").click(function () {
            missions = [];
            commodities = [];
            $("#missions-table tbody").empty();
            $("#calculate-route-button").hide();
            $("#route-output").empty();
            currentRoute = [];
            routeSegments = [];
            drawMap([]);
        });

        // Calculate Route Button Click Event
        $("#calculate-route-button").click(function () {
            const startingLocation = $("#starting-location").val().trim();
            if (!startingLocation) {
                alert("Please enter a starting location.");
                return;
            }
            calculateAndDisplayOptimizedRoute(startingLocation);
        });

        // Function to Calculate and Display the Optimized Route
        let currentRoute = [];
        let routeSegments = [];

        function calculateAndDisplayOptimizedRoute(startingLocation) {
            let availableLocations = allLocations.filter(loc => celestialBodies[loc] || locationTypes[loc]);

            if (!availableLocations.includes(startingLocation)) {
                alert("Invalid starting location.");
                return;
            }

            // Build list of all locations and dependencies
            let locationsSet = new Set();
            let dependencies = [];

            commodities.forEach(commodity => {
                locationsSet.add(commodity.pickup);
                locationsSet.add(commodity.dropoff);
                dependencies.push({ from: commodity.pickup, to: commodity.dropoff });
            });

            locationsSet.add(startingLocation);

            // Include orbital station if starting from a planetary location and cargo pickup is required from the orbital station
            let startingLocationType = locationTypes[startingLocation];
            let homePlanet = locationToPlanet[startingLocation] || startingLocation;
            let homeOrbitalStation = orbitalStations[homePlanet];

            let requiresPickupFromOrbitalStation = commodities.some(commodity => {
                return commodity.pickup === homeOrbitalStation;
            });

            if ((startingLocationType === 'Planet' || startingLocationType === 'Moon') && requiresPickupFromOrbitalStation) {
                locationsSet.add(homeOrbitalStation);
                dependencies.push({ from: startingLocation, to: homeOrbitalStation });
            }

            // Build distance matrix
            let locations = Array.from(locationsSet);
            let distanceMatrix = {};
            locations.forEach(loc1 => {
                distanceMatrix[loc1] = {};
                locations.forEach(loc2 => {
                    if (loc1 === loc2) {
                        distanceMatrix[loc1][loc2] = 0;
                    } else {
                        distanceMatrix[loc1][loc2] = calculateDistance(getPosition(loc1), getPosition(loc2));
                    }
                });
            });

            // Build graph with dependencies (pickups before drop-offs)
            let graph = {};
            locations.forEach(loc => {
                graph[loc] = new Set();
            });

            dependencies.forEach(dep => {
                graph[dep.from].add(dep.to);
            });

            // Initialize route
            let route = [startingLocation];
            let visited = new Set();
            let currentLocation = startingLocation;

            let carriedCommodities = [];
            routeSegments = [];

            // Assign missionIndex to commodities
            commodities.forEach(c => {
                c.pickedUp = false;
                c.droppedOff = false;
                c.missionIndex = null;
            });

            missions.forEach((mission, missionIndex) => {
                mission.commodities.forEach(commodity => {
                    commodity.missionIndex = missionIndex;
                });
            });

            // Function to check if all dependencies are satisfied
            function dependenciesSatisfied(visited) {
                for (let dep of dependencies) {
                    if (visited.has(dep.to) && !visited.has(dep.from)) {
                        return false;
                    }
                }
                return true;
            }

            // Generate route respecting dependencies
            while (visited.size < locations.length || carriedCommodities.length > 0) {
                // Mark current location as visited
                visited.add(currentLocation);

                // Process pickups and drop-offs at current location
                commodities.forEach(commodity => {
                    if (commodity.pickup === currentLocation && !commodity.pickedUp) {
                        carriedCommodities.push(commodity);
                        commodity.pickedUp = true;
                    }
                });

                carriedCommodities.forEach(commodity => {
                    if (commodity.dropoff === currentLocation && !commodity.droppedOff) {
                        commodity.droppedOff = true;
                    }
                });

                // Remove dropped off commodities from carriedCommodities
                carriedCommodities = carriedCommodities.filter(c => !c.droppedOff);

                // Find next possible locations
                let possibleNextLocations = locations.filter(loc => loc !== currentLocation);

                // Filter out locations whose dependencies are not met
                possibleNextLocations = possibleNextLocations.filter(loc => {
                    for (let dep of dependencies) {
                        if (dep.to === loc && !visited.has(dep.from)) {
                            return false;
                        }
                    }
                    return true;
                });

                // Exclude already visited locations unless there are pending pickups or drop-offs there
                possibleNextLocations = possibleNextLocations.filter(loc => {
                    if (!visited.has(loc)) {
                        return true;
                    }
                    // Check if there are pending pickups or drop-offs at this location
                    return commodities.some(c => ((c.pickup === loc && !c.pickedUp) || (c.dropoff === loc && !c.droppedOff)));
                });

                if (possibleNextLocations.length === 0) {
                    break;
                }

                // Choose the nearest next location
                let nearestLocation = null;
                let minDistance = Infinity;
                for (let loc of possibleNextLocations) {
                    let dist = distanceMatrix[currentLocation][loc];
                    if (dist < minDistance) {
                        minDistance = dist;
                        nearestLocation = loc;
                    }
                }

                if (nearestLocation) {
                    // Determine which missions are being served in this segment
                    let missionsInSegment = new Set();

                    // Update carried commodities before moving to next location
                    // Process pickups and drop-offs at current location
                    commodities.forEach(commodity => {
                        if (commodity.pickup === currentLocation && !commodity.pickedUp) {
                            carriedCommodities.push(commodity);
                            commodity.pickedUp = true;
                        }
                    });

                    carriedCommodities.forEach(commodity => {
                        if (commodity.dropoff === currentLocation && !commodity.droppedOff) {
                            commodity.droppedOff = true;
                        }
                    });

                    // Remove dropped off commodities from carriedCommodities
                    carriedCommodities = carriedCommodities.filter(c => !c.droppedOff);

                    carriedCommodities.forEach(commodity => {
                        missionsInSegment.add(commodity.missionIndex);
                    });

                    // Add segment to routeSegments
                    routeSegments.push({
                        from: currentLocation,
                        to: nearestLocation,
                        missions: Array.from(missionsInSegment)
                    });

                    route.push(nearestLocation);
                    currentLocation = nearestLocation;
                } else {
                    break;
                }
            }

            currentRoute = route;

            displayOptimizedRoute(route, distanceMatrix);
            drawMap(route);
        }

        // Function to get the position of a location
        function getPosition(location) {
            if (celestialBodies[location]) {
                return celestialBodies[location];
            } else if (locationTypes[location] === 'Planet') {
                return celestialBodies[location];
            } else if (locationTypes[location] === 'Moon') {
                return celestialBodies[location];
            } else if (locationTypes[location] === 'Orbital Station') {
                return celestialBodies[locationToPlanet[location]]; // Use planet's position
            } else if (locationTypes[location] === 'Lagrange Point' || locationTypes[location] === 'Jump Point') {
                return celestialBodies[location];
            } else {
                // No position assigned
                return null;
            }
        }

        // Function to Calculate Distance Between Two Locations
        function calculateDistance(pos1, pos2) {
            if (!pos1 || !pos2) return Infinity;
            const dx = pos2.x - pos1.x;
            const dy = pos2.y - pos1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Function to Display the Optimized Route
        function displayOptimizedRoute(route, distanceMatrix) {
            let output = `<h3>Optimized Route</h3>`;
            output += `<ol>`;
            let totalDistance = 0;

            let carriedCommodities = [];

            // Reset pickedUp and droppedOff flags
            commodities.forEach(c => {
                c.pickedUp = false;
                c.droppedOff = false;
            });

            for (let i = 0; i < route.length; i++) {
                const loc = route[i];
                output += `<li><strong>${loc}</strong>`;
                // Show commodities to pick up or drop off at this location
                let pickups = {};
                let dropoffs = {};

                commodities.forEach(commodity => {
                    if (commodity.pickup === loc && !commodity.pickedUp) {
                        if (!pickups[commodity.type]) {
                            pickups[commodity.type] = 0;
                        }
                        pickups[commodity.type] += commodity.amount;
                        carriedCommodities.push(commodity);
                        commodity.pickedUp = true;
                    }
                });

                carriedCommodities.forEach(commodity => {
                    if (commodity.dropoff === loc && !commodity.droppedOff) {
                        if (!dropoffs[commodity.type]) {
                            dropoffs[commodity.type] = 0;
                        }
                        dropoffs[commodity.type] += commodity.amount;
                        commodity.droppedOff = true;
                    }
                });

                if (Object.keys(pickups).length > 0) {
                    let pickupStr = Object.entries(pickups).map(([type, amount]) => `${type} (${amount} SCU)`).join(', ');
                    output += `<br>Pick up: ${pickupStr}`;
                }
                if (Object.keys(dropoffs).length > 0) {
                    let dropoffStr = Object.entries(dropoffs).map(([type, amount]) => `${type} (${amount} SCU)`).join(', ');
                    output += `<br>Drop off: ${dropoffStr}`;
                    // Remove dropped off commodities from carriedCommodities
                    carriedCommodities = carriedCommodities.filter(c => !(c.dropoff === loc && c.droppedOff));
                }
                output += `</li>`;

                // Calculate distance to next location
                if (i < route.length - 1) {
                    totalDistance += distanceMatrix[route[i]][route[i + 1]];
                }
            }
            output += `</ol>`;
            output += `<p><strong>Total Path Length:</strong> ${totalDistance.toFixed(2)} units</p>`;

            // Display mission color legend
            output += `<h4>Mission Legend</h4><ul>`;
            missions.forEach((mission, index) => {
                output += `<li><span style="color:${mission.color}"></span> Mission ${index + 1}: ${mission.missionType} (${mission.missionSubcategory})</li>`;
            });
            output += `</ul>`;

            $("#route-output").html(output);

            // Reset pickedUp and droppedOff flags for future calculations
            commodities.forEach(c => {
                delete c.pickedUp;
                delete c.droppedOff;
            });
        }

        // Variables for zoom and pan
        let baseScale = 1;
        let scale = 1;          // Zoom level
        let panX = 0;           // Horizontal pan
        let panY = 0;           // Vertical pan
        let isDragging = false; // Drag state
        let dragStart = { x: 0, y: 0 }; // Drag starting point

        // Function to Draw the Map and Route
        function drawMap(route) {
            const canvas = document.getElementById('route-map');
            const ctx = canvas.getContext('2d');

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save the context before applying transformations
            ctx.save();

            // Apply pan and zoom
            ctx.translate(panX, panY);
            ctx.scale(scale, scale);

            // Get all positions
            const positions = Object.values(celestialBodies);
            const xValues = positions.map(pos => pos.x);
            const yValues = positions.map(pos => pos.y);

            // Center the star
            const padding = 50;
            const starPos = celestialBodies['Stanton Star'];

            // Shift positions so that the star is at (0,0)
            const shiftedPositions = positions.map(pos => {
                return {
                    x: pos.x - starPos.x,
                    y: pos.y - starPos.y
                };
            });

            // Get min and max of shifted positions
            const xValuesShifted = shiftedPositions.map(pos => pos.x);
            const yValuesShifted = shiftedPositions.map(pos => pos.y);

            const minX = Math.min(...xValuesShifted);
            const maxX = Math.max(...xValuesShifted);
            const minY = Math.min(...yValuesShifted);
            const maxY = Math.max(...yValuesShifted);

            baseScale = (canvas.width - 2 * padding) / (maxX - minX);

            // Function to transform celestial coordinates to canvas coordinates
            function transform(pos) {
                const shiftedX = pos.x - starPos.x;
                const shiftedY = pos.y - starPos.y;
                return {
                    x: (canvas.width / 2 + shiftedX * baseScale),
                    y: (canvas.height / 2 - shiftedY * baseScale)
                };
            }

            // Determine thresholds for visibility
            const moonVisibilityThreshold = 1.5;
            const planetaryLocationThreshold = 2.0;
            const moonLocationThreshold = 3.0;
            const lagrangeLabelThreshold = 1.5;
            const moonOrbitVisibilityThreshold = 2.0;
            const moonLabelThreshold = 2.0;
            const jumpPointLabelThreshold = 1.0;
            const orbitalStationVisibilityThreshold = 2.0;

            // Draw orbital circles for planets
            const planetNames = ["Hurston", "Crusader", "ArcCorp", "MicroTech"];
            planetNames.forEach(planet => {
                const planetPos = celestialBodies[planet];
                const distance = Math.hypot(planetPos.x - starPos.x, planetPos.y - starPos.y);
                const canvasPos = transform(starPos);
                const radius = distance * baseScale;

                ctx.beginPath();
                ctx.arc(canvasPos.x, canvasPos.y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 0.5 / scale;
                ctx.stroke();
            });

            // Draw celestial bodies
            for (let loc in celestialBodies) {
                const pos = celestialBodies[loc];
                const canvasPos = transform(pos);

                // Decide whether to draw moons
                if (locationTypes[loc] === 'Moon') {
                    if (scale <= moonVisibilityThreshold) {
                        continue; // Skip drawing moons at low zoom levels
                    }
                }

                // Decide whether to draw orbital stations
                if (locationTypes[loc] === 'Orbital Station') {
                    if (scale <= orbitalStationVisibilityThreshold) {
                        continue;
                    }
                }

                // Draw celestial body
                ctx.beginPath();
                ctx.arc(canvasPos.x, canvasPos.y, 3 / scale, 0, 2 * Math.PI);

                if (loc === 'Stanton Star') {
                    ctx.fillStyle = 'yellow';
                } else if (locationTypes[loc] === 'Planet') {
                    ctx.fillStyle = 'blue';
                } else if (locationTypes[loc] === 'Moon') {
                    ctx.fillStyle = 'lightblue';
                } else if (locationTypes[loc] === 'Jump Point') {
                    ctx.fillStyle = 'purple';
                } else if (locationTypes[loc] === 'Lagrange Point') {
                    ctx.fillStyle = 'green';
                } else if (locationTypes[loc] === 'Orbital Station') {
                    ctx.fillStyle = 'white';
                } else {
                    ctx.fillStyle = 'gray';
                }
                ctx.fill();

                // Label important locations
                ctx.fillStyle = 'white';
                ctx.font = `${12 / scale}px Arial`;
                ctx.textAlign = 'left';

                // Adjust label positions slightly to avoid overlap
                let labelOffsetX = 5 / scale;
                let labelOffsetY = -5 / scale;

                if (locationTypes[loc] === 'Planet' || loc === 'Stanton Star') {
                    ctx.fillText(loc, canvasPos.x + labelOffsetX, canvasPos.y + labelOffsetY);
                } else if (locationTypes[loc] === 'Moon') {
                    if (scale > moonLabelThreshold) {
                        ctx.fillText(loc, canvasPos.x + labelOffsetX, canvasPos.y + labelOffsetY);
                    }
                } else if (locationTypes[loc] === 'Lagrange Point') {
                    if (scale > lagrangeLabelThreshold) {
                        ctx.fillText(loc, canvasPos.x + labelOffsetX, canvasPos.y + labelOffsetY);
                    }
                } else if (locationTypes[loc] === 'Jump Point') {
                    if (scale > jumpPointLabelThreshold) {
                        ctx.fillText(loc, canvasPos.x + labelOffsetX, canvasPos.y + labelOffsetY);
                    }
                } else if (locationTypes[loc] === 'Orbital Station') {
                    if (scale > orbitalStationVisibilityThreshold) {
                        ctx.fillText(loc, canvasPos.x + labelOffsetX, canvasPos.y + labelOffsetY);
                    }
                }
            }

            // Draw orbital rings for moons when zoomed in
            if (scale > moonOrbitVisibilityThreshold) {
                // For each planet
                planetNames.forEach(planet => {
                    const planetPos = celestialBodies[planet];
                    const moons = moonOrders[planet];
                    if (moons) {
                        moons.forEach((moonName, moonIndex) => {
                            const orbitalRadius = (2.5 + (moonIndex * 0.5)) * baseScale;

                            const canvasPos = transform(planetPos);

                            ctx.beginPath();
                            ctx.arc(canvasPos.x, canvasPos.y, orbitalRadius, 0, 2 * Math.PI);
                            ctx.strokeStyle = 'lightgray';
                            ctx.lineWidth = 0.5 / scale;
                            ctx.stroke();
                        });
                    }
                });
            }

            // Draw the route
            if (route && route.length > 1) {
                for (let i = 0; i < routeSegments.length; i++) {
                    const segment = routeSegments[i];
                    const fromPos = transform(getPosition(segment.from));
                    const toPos = transform(getPosition(segment.to));

                    // Determine color based on missions involved
                    let color = 'red'; // Default color
                    if (segment.missions.length === 1) {
                        color = missions[segment.missions[0]].color;
                    } else {
                        color = 'white'; // If multiple missions, use white
                    }

                    ctx.beginPath();
                    ctx.moveTo(fromPos.x, fromPos.y);
                    ctx.lineTo(toPos.x, toPos.y);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2 / scale;
                    ctx.stroke();

                    // Draw arrowhead
                    const dx = toPos.x - fromPos.x;
                    const dy = toPos.y - fromPos.y;
                    const angle = Math.atan2(dy, dx);
                    const arrowSize = 10 / scale;

                    ctx.save();
                    ctx.translate(toPos.x, toPos.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-arrowSize, arrowSize / 2);
                    ctx.lineTo(-arrowSize, -arrowSize / 2);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Restore the context
            ctx.restore();

            // Display location list when zoomed in on a planet or moon
            displayLocationList();
        }

        // Function to display location list when zoomed in
        function displayLocationList() {
            const overlay = document.getElementById('location-list-overlay');
            overlay.style.display = 'none'; // Hide by default

            // Determine if we are zoomed in on a planet or moon
            if (scale > 2.5) {
                const canvas = document.getElementById('route-map');
                const rect = canvas.getBoundingClientRect();
                const centerX = (canvas.width / 2 - panX) / scale;
                const centerY = (canvas.height / 2 - panY) / scale;

                let closestBody = null;
                let minDist = Infinity;

                for (let loc in celestialBodies) {
                    if (locationTypes[loc] === 'Planet' || locationTypes[loc] === 'Moon') {
                        const pos = celestialBodies[loc];
                        const posX = (pos.x - celestialBodies['Stanton Star'].x) * baseScale;
                        const posY = -(pos.y - celestialBodies['Stanton Star'].y) * baseScale;

                        const dx = posX - centerX;
                        const dy = posY - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < minDist && dist < 50 / scale) { // Adjust threshold as needed
                            minDist = dist;
                            closestBody = loc;
                        }
                    }
                }

                if (closestBody) {
                    // Display the list of locations for this planet or moon
                    overlay.innerHTML = `<h3>${closestBody} Locations</h3><ul>`;
                    if (locationTypes[closestBody] === 'Planet') {
                        const planetaryLocations = data[closestBody]['Planetary Locations'];
                        for (let category in planetaryLocations) {
                            if (category === "Orbital Station") continue; // Skip orbital stations
                            const locations = planetaryLocations[category];
                            if (typeof locations === 'string') {
                                overlay.innerHTML += `<li>${locations}</li>`;
                            } else if (Array.isArray(locations)) {
                                locations.forEach(loc => {
                                    overlay.innerHTML += `<li>${loc}</li>`;
                                });
                            }
                        }
                        // Include moon names
                        if (data[closestBody]['Moons']) {
                            for (let moon in data[closestBody]['Moons']) {
                                overlay.innerHTML += `<li><strong>${moon}</strong></li>`;
                            }
                        }
                    } else if (locationTypes[closestBody] === 'Moon') {
                        const planet = locationToPlanet[closestBody];
                        const moonLocations = data[planet]['Moons'][closestBody];
                        moonLocations.forEach(loc => {
                            overlay.innerHTML += `<li>${loc}</li>`;
                        });
                    }
                    overlay.innerHTML += '</ul>';
                    overlay.style.display = 'block';
                }
            }
        }

        // Event Listeners for Zoom and Pan
        const canvas = document.getElementById('route-map');

        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;
            const wheel = e.deltaY < 0 ? 1 : -1;
            const zoom = Math.exp(wheel * zoomIntensity);

            // Adjust pan to zoom towards cursor
            panX -= (mouseX - panX) * (zoom - 1);
            panY -= (mouseY - panY) * (zoom - 1);

            scale *= zoom;
            drawMap(currentRoute);
        });

        canvas.addEventListener('mousedown', function(e) {
            isDragging = true;
            dragStart.x = e.clientX - panX;
            dragStart.y = e.clientY - panY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', function(e) {
            if (isDragging) {
                panX = e.clientX - dragStart.x;
                panY = e.clientY - dragStart.y;
                drawMap(currentRoute);
            }
        });

        canvas.addEventListener('mouseup', function() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', function() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        // Reset Map Button
        document.getElementById('reset-map-button').addEventListener('click', function() {
            scale = 1;
            panX = 0;
            panY = 0;
            drawMap(currentRoute);
        });

        // Helper function to generate a random position around a central point
        function generateRandomPositionAround(center, radius) {
            const angleRad = Math.random() * 2 * Math.PI;
            const r = radius * Math.sqrt(Math.random());
            const x = center.x + r * Math.cos(angleRad);
            const y = center.y + r * Math.sin(angleRad);
            return { x: x, y: y };
        }

        // Initial draw
        drawMap([]);

    </script>

</body>
</html>
